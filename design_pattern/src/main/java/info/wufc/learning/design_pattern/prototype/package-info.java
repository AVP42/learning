/**
 *  【对象的创建模式】原型模式：
 *      0. 理解：
 *          0.1 一句话概括：
 *          0.2 java本身支持这种模式，通过实现Cloneable接口就可以调用clone()方法
 *                 Cloneable接口仅仅起到标识作用，表示可以安全的调用clone方法，
 *                 Object类中的clone方法实现，对于引用，仅仅是将引用复制一份。
 *                 可以对clone方法复写，实现自定义的复制逻辑。
 *      1. 用意：给定一个原型对象，用复制该对象的方式来创建更多同类型的对象。
 *      2. 结构：
 *          2.1 简单形式
 *              抽象原型 Prototype extends Cloneable
 *              具体原型 ConcretePrototype
 *          2.2 注册形式
 *              原型管理器 PrototypeManager：负责创建具体原型类的对象，并记录每一个对象
 *      3. 是否满足开闭原则
 *      4. 应用场景 作为创建模式，原始模型模式解决了工厂模式的一些缺点，主要应用以下场景
 *          4.1  由于原型模式不关心对象是怎么创建出来的，以及对象内部的引用的结构的怎样的，已经这个结构是否会发生变化
 *              所以如果一个系统中的产品类时动态加载的，而且产品具有一定的等级机构，使用原型模式会更加方便。
 *              考虑使用工厂模式的话，由于产品类具有一定的等级结构，所以工厂类也不得不有一个相应的等级结构。
 *              这时，如果产品类的机构发生了变化，那么工厂类的等级结构也不得不发生变化。
 *              使用原型模式的话，只需要给每一个产品类配备一个克隆方法（大多时候只需要对产品类结构的基类配备），
 *              便可以避免使用工厂模式带来的具有固定等级结构的工厂
 *      5. 实现
 *          5.1 浅复制 vs 深复制
 *              浅复制---仅仅考虑该对象，不考虑其引用的对象，对其他对象引用复制后依然指向原来的对象
 *              深复制---考虑对其他对象的引用，复制后指向的是新的其他对象。
 *                  深复制需要考虑要深入几层，下面的层次是继续深复制还是浅复制等问题
 *                  深复制在复制过程很可能出现循环引用的问题。
 *              利用串行化来做深复制：串行化Serialization是指将对象写到流上。对应的是并行化Deserialization。
 *                  串行化（腌咸菜/冷冻）时，写到流中的是对象的一个拷贝，原对象还在JVM里面，还可以“回鲜/解冻”成一个对象。
 *              在java中要深复制一个对象，常常可以先使对象实现Serializable接口，然后将对象写到流中，然后再从流中读回来。
 *                      注意：对于无法串行化的对象，
 *                          可以设置成transient。将其排除在复制过程之外。比如Thread对象或者Socket独享。
 *                          或者自行创建出相同的对象，当作复制出来的使用。
 *           5.2 简单形式 vs 等级形式
 *              如果原型对象比较少，可以单独使用变量来应用每一个原型，使用简单形式就好
 *              如果原型对象比较多，或者数量不固定，且动态变化，可以通过一个管理着来维护这些对象。
 *      6. 与其他模式的关系
 *          6.1 与抽象工厂模式：如果系统不需要动态的改变原型对象，抽象工程可以称为原始模型的替代品。
 *          6.2 与合成模式：经常一起使用，因为原型对象经常是合成对象。
 *          6.3 与门面模式：原始模型模式的客户端通常可以是facade，将系统其它对象与参与原始模型模式的对象分隔开。
 *          6.4 与工厂方法模式：如果原型对象只有一种，而且不会增加，工厂方法模式可以称为一种替代模式。
 *          6.5 与装饰模式：通常与装饰模式一起使用。
 *
 *
 *      7. 实例：
 *          7.1 孙悟空拔毛复制身外之身
 *      8. 优缺点
 *          几种创建模式的共同点：
 *               抽象工厂模式，原始模型模式，建造模式有一些共同的效果，包括客户端不知道具体产品类(只知道具体的工厂类或者建造类），
 *                    只知道抽象产品类，这样，客户端就不需要知道这么多的具体产品名称，如果有产品加入，客户端不需要进行改造就可以直接使用。
 *          优点：原型模式的特有优点：
 *              1）允许动态的增加或者减少产品类，因为创建产品的方法是产品类内部具有的，所以增加或者删除产品对这个结构没有影响
 *              2）原型模式提供了简化的创建结构，工厂方法模式常常需要一个与产品类等级结构相同的等级结构。
 *              3）第1点的优点，可以使得系统层面可以动态加载新功能的能力，如果需要新的产品，只需要克隆任意一个对象，进行登记等简单处理后就可以了。
 *              4）产品类不需要具有登记结构，原型模式适用于任何的等级结构。
 *          缺点：每一个类都唏嘘配备一个克隆方法，而配备一个clone方法，需要对类的功能进行全盘考虑，对于新的类还好，对于已经有的类就不一定很容易。
 *              特别是当一个类应用不支持串行化的间接对象，或者包含循环结构的时候。
 *
 */
package info.wufc.learning.design_pattern.prototype;
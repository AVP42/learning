/**
 * 代理模式：提供一个代理对象，持有真实对象，由代理对象控制真实对象的引用
 *      1.角色：
 *          1.1 代理角色
 *          1.2 真实角色
 *      2.根据代理目的的分类
 *          2.1 虚拟代理：对加载过程缓慢，耗费资源较大的正式对象，只有在被需要的时候才会被加载
 *          2.2 远程代理：RMI
 *          2.3 保护代理：控制对真实对象访问的权限等
 *          2.4 智能引用代理：记录对象被引用的次数等
 *          2.5 其他
*       3.根据代理实现方式分类：
 *          3.1 静态代理（编译前定义好代理类）
 *          3.2 动态代理（运行时期生成代理类）
 *              3.2.1 jdk 动态代理
 *                      1） 使用：使用Proxy.newProxyInstance(ClassLoader loader, 类加载器
 *                                           Class<?>[] interfaces, 需要代理那些接口
 *                                           InvocationHandler h) 动态代理类回调的方法 控制逻辑写在这里
 *                      2） 缺点：只能通过接口实现代理，且全部分发的代理都是通过InvocationHandler来控制（也就是接口中的所有方法都经过invoke方法）
 *
 *              3.2.2 cglib动态代理
 *                      1） 使用使用org.springframework.cglib.proxy.Enhancer
 *                      分别设置 enhancer.setClassLoader() 类加载器
 *                             enhancer.setSuperClass() 需要代理那些超类
 *                             enhancer.setCallBack(InvocationHandler) 动态代理类回调的方法，控制逻辑写在这里
 *                      2） 优缺点：只能通过继承超类，重写方法代理（不适用于不可继承的类以及不可被覆盖的方法，比如final类，final、static、private方法），同样代理的最小维度也是类
 *      4.与其他模式的关系
 *          3.1 适配器模式：适配器模式旨在改变对象的接口，让对象实现新的接口来实现新的功能；而代理模式不会改变对象的接口
 *          3.2 装饰模式：装饰对象和代理对象都会实现真实对象的接口，但是主要体现在功能的不同：
 *                      装饰模式主要用于对对象提供增强功能（主角光环护体），代理模式主要用于对对象的控制（挟天子以令诸侯）
 *          3.3 门面模式：门面模式可以通过代理模式来实现，此时称为门面代理模式或者代理门面模式
 *      5.是否实现开闭原则：
 *          这里的功能拓展应该是对对象控制的拓展，当提出一个新需求，需要特定角色才可以访问对象时，我们可以通过多重代理来实现，此时满足“开-闭”原则
 *
 */
package info.wufc.learning.design_pattern.proxy;
/**
 *  模版方法模式：【行为模式】
 *    1. 用意：准备一个抽象类，将功能实现（模版方法）的部分实现逻辑以具体方法的形式实现，部分实现逻辑以抽象方法或者钩子方法的形式交给子类来实现
 *          >> 状态模式，策略模式，装饰模式，桥梁模式，抽象工厂模式 均是将依赖于类的继承转换为基于对象的组合或者聚合的实现方式，即使用委派关系代替继承关系
 *          >> 模版方式模式鼓励恰当使用继承模式
 *    2. 角色： 抽象模版角色   具体模版角色
 *          模版方法模式中的方法可以分成两大类
 *          >> 模版方法：定义在抽象类中，将基本操作方法组合在一起形成一个中的算法或者总行为的方法。
 *          >> 基本方法：
 *              >>> 具体方法：子类非一定得复写的方法，可以是一些工厂方法
 *              >>> 抽象方法：子类必须实现的抽象方法
 *              >>> 钩子方法：子类一般需要复写的方法，父类一般是空实现
 *          ** 设计理念：极可能减少子类需要复写的基本方法个数
 *                  * 钩子方法：比如在缺省适配器的应用
 *                  * 钩子方法命名应当以“do”作为前缀
 *     3.在重构中的应用：
 *              1. 将大方法的方法体打碎成多个小方法的调用，即改成模版方法，小方法就是具体方法，可以是抽象类实现，或者默认钩子实现，或者需要子类实现的。
 *              2. 以多态性取代条件转移：即模版方法中如果有条件选择，可以将条件选择下沉至子类进行，模版方法就可以不关心条件逻辑，转移到子类
 *          重构原则：对于一个继承的等级结构进行重构时，将行为移动到结构顶端，将状态移动到结构低端
 *              1. 应该根据行为来定义一个类，而不是状态。即一个类的实现首先应当建立在行为的基础之上，而不是状态之上
 *              2. 在实现行为时，应当使用抽象状态，而不是具体状态。如果行为涉及到使用状态，应当使用间接引用，而不是直接引用。
 *                  也就是通过取值的方法，而不是直接引用变量。
 *                  对于常量，也是建立常量取值方法，与可变属性一样。
 *              3. 给操作划分层次，一个类的行为应当放到一个小组核心方法，使得可以在子类中方便替换。即分清基本方法和模版方法
 *              4. 最后将状态的确认推迟到子类中。即不要在抽象类中过早声明属性变量（如果抽象类中需要使用，则使用取值方法），应当推迟到子类中声明
 *          * 遵循这些原则，可以达到很大程度的复用
 */
package info.wufc.learning.design_pattern.template;
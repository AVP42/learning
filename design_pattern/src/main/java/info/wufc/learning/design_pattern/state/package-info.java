/**
 * 【对象的行为模式】 状态模式，  状态对象模式
 *      0. 理解
 *          0.1 一句话概括：状态模式将所研究对象的行为包装在不同的状态对象里。
 *          0.2 特点：状态同一时间只能有一种，所以通过关联一个抽象状态，就可以实现一次次委派的操作。
 *      1. 用意：状态模式意图在于让一个对象在其内部状态发生改变时，其行为也发生了改变。这个对象看上去像是改了它的类一样。
 *              很多时候，一个对象的行为取决于一个或者多个动态变化的属性(状态），这样的对象叫做有状态（stateful）对象
 *              这些状态是预先定好的，当与外部事件产生互动式，内部状态就会发生改变，从而使得系统行为也随之改变。
 *      2. 结构  将context的行为与状态的依赖巧妙地通过委派关系，把环境角色的行为委派给一个个状态的行为。
 *          2.1 抽象状态角色 State: 定义和封装环境（context）对象的一个特定状态所对应的行为。
 *          2.2 具体状态角色 ConcreteState：抽象状态角色的实现
 *          2.3 环境角色 Context：所要考察的类，保留一个具体状态作为当前状态。所要考察的类的行为是委派给某一个具体的状态类的
 *      3. 是否满足开闭原则
 *      4. 应用场景：
 *          4.1 一个对象的行为依赖其说处于的状态，对象的行为必须随着状态的改变而改变 >> 订单
 *          4.2 对象在某个方法内依赖于一重或者多重的条件转移语句，其中有大量的代码，状态模式把条件转移语句的每一个分支都包装到
 *              一个单独的类中。这使得这些条件转移分支能够以类的方式独立存在和演化，维护这些独立的类不再系统的其他部分
 *      5. 实现：
 *          5.1 谁来定义状态的变化
 *              状态模式没有规定哪个角色来决定。
 *              1） 如果转换条件是固定的，那么就应当由context角色来做。
 *              比如编钟，如果曲子是固定的，则可以将曲子存储在编钟里，编钟自行触发状态的变化，引发对应的行为变化。
 *              2） 如果让State子类执行决定下一个继任者就谁，以及在什么时候转换，就更有灵活性。
 *              3） 由外界事件来决定状态的装换，比如订单状态的变化。
 *          5.2 状态对象的创建和湮灭
 *              1） 动态创建需要的对象，按需创建。不需要则销毁。适合状态加载成本不高以及变化缓慢的情况。
 *              2） 事先创建，适合状态变化比较快，加载成本高的情况。
 *              3） 环境类也可以把自己作为参量传给状态对象，以便状态在触发行为的时候获取上下文信息。或者指定下一个状态。
 *
 *      6. 与其他模式的关系
 *          6.1 与享元模式：状态对象基本上是只有行为而没有内部状态的享元模式
 *          6.2 与策略模式：比较容易混淆
 *                  1） 考察环境角色是否有明显的状态和状态的过度，如果只有一个状态，应当使用策略模式。
 *                      因为策略模式中，一旦环境角色选择了一个具体策略类，这个环境类的生命周期里都不会改变这个具体策略类
 *                      而状态模式适用于另一种情况，即环境角色有明显的状态转移。
 *                  2） 策略模式的环境类制剂选择一个具体的策略类，而状态模式的环境类时被外在原因放入一个具体的状态中。
 *                  3） 策略模式并不明显告诉客户端其所选择的具体策略；而状态模式中环境角色所处的状态是明显告诉客户端的。
 *          6.3 与命令模式(个人)：
 *                  环境角色所持有的只有一个状态对象，而invoker角色可以持有多个命令或者宏命令。
 *                  执行过程中，环境角色所持有的状态是可能变化的，而且可能是由前面一个状态决定的，比如订单支付后进入已支付状态。
 *                  而命令模式在执行过程中，一般来说invoker中的命令是已经固定了的。
 *
 *      7. 实例
 *          7.1 编钟：内部有很多个不同的钟，
 *              每个钟对应了一种state，每个钟都有自己的被打击行为，编钟对应着Context，该实例给出此编钟现在发的声
 *              通过状态模式，将编钟的行为与状态的依赖巧妙地通过委派，把编钟的行为委派给一只只的种。
 *              加入没有使用状态模式，编钟可能需要维护这些钟(状态),并向Client提供不同状态的行为。
 *          7.2 TCP 状态
 *              context角色：TcpConnection
 *              ConcreteState角色:Established, Listening, Closed.
 *              当TcpConnection街道其他对象的请求时，会根据其状态不同给出不同的回应。
 *      8. 优缺点：
 *          优点：充分利用JAVA的多态特性，使得程序免于大量的条件转移语句，也就是将一个发生了状态转移的操作，抽取出来成为状态类，交给状态类来完成
 *                  新加状态只需要以子类的方式加入即可。
 *          缺点：可能会造成大量小的状态类
 *
 */
package info.wufc.learning.design_pattern.state;
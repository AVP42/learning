# 总结
## 一、设计模式概览
### 1.1 创建模式
#### 1.1.1 简单工厂模式（静态工厂模式）--类的创建模式
#### 1.1.2 工厂方法模式（多态工厂模式）--类的创建模式
#### 1.1.3 抽象工厂模式--对象的创建模式
#### 1.1.4 单例模式--对象的创建模式
[Ref](https://cloud.tencent.com/developer/article/1497592)
* 1.饿汉式- 静态属性
* 2.饿汉式- 枚举类
    单例类本身是个枚举类
* 3.懒汉式- 线程不安全
* 4.懒汉式- synchronized
* 5.懒汉式- volatile + doubleCheck
  > volatile 解决指令重排序问题；<br>
  > doubleCheck提供效率更高获取实例方法
* 6.懒汉式- 内部静态类
* 7.懒汉式- 内部枚举类 本质上上第6中
#### 1.1.5 多例模式--对象的创建模式
多例类自行创建，管理自己的实例，并向外界提供自己的实例
#### 1.1.5 建造模式--对象的创建模式
将产品内部表象和产品的生产过程分割开来，可以创建具有不同表象的产品对象。

与Java Bean的builder类似，只是在其基础上增加了Director角色，使得可以通过一个construct方法（建造过程）就可以生成不同的产品。
建造者模式的关键是可以使得建造出来的对象具有不同的内部表象（即成员变量的值不一样），所以称为对象的创建模式
抽象工厂模式由于可以对产品族进行组装，所以得到的对象也是不同的对象，也是一种对象的创建模式
而像简单工厂模式，工厂方法模式，创建出来的都是相同的对象，所以是一种类的创建模式。 

建造者模式可以先利用抽象工厂模式创建出对象，然后再在Builder中设置相关性质。

比如spring的BeanDefinitionBuilder
    
#### 1.1.6 原型模式--对象的创建模式
基于原型对象来复制更多的同类型对象

### 1.2 结构模式
结构模式描述如何将类或者对象结合在一起形成一个更大的结构

#### 1.2.1 适配器模式 Adapter
适配器模式通过一个adapter类将一个类的接口(adaptee)变换成客户端所期待的另外一种接口(target).

#### 1.2.2 缺省适配器模式 Default Adapter
缺省适配器模式是特殊的适配器模式，adaptee和target是同一个接口，adapter是为这个接口提供缺省实现，使得子类不必从原有接口进行拓展。

#### 1.2.3 合成模式 Composite -- 对象的结构模式
合成模式用来描述整体与部分的关系，可以将对象组织到树结构中。客户端可以将单纯元素和符合元素同等看待。

#### 1.2.4 装饰模式 Decorator/Wrapper -- 对象的结构模式
装饰模式通过委派的方式而非继承的方式来对一个对象的功能加以拓展。

#### 1.2.5 代理模式 Proxy -- 对象的结构模式
代理模式通过代理对象控制原对象的行为，达到“挟天子以令诸侯”的效果，并不是为了增强原有对象的功能。

#### 1.2.6 享元模式 Flyweight -- 对象的结构模式
享元模式通过只包含不随环境变化的内蕴状态的享元对象来实现共享，来支持大量细粒度的对象。

#### 1.2.7 门面模式 Facade -- 对象的结构模式
门面模式通过一个门面对象来屏蔽子系统内部的协作细节，向外部提供统一的更高层次的接口。

#### 1.2.8 桥梁模式 Bridge/Interface -- 对象的结构模式
桥梁模式可以将一个等级结构通过组合复用的脱耦层抽象化和实现化两个等级结构，使得两个等级结构可以独立的进行演化。

### 1.3 行为模式
行为模式是对不同对象之间划分责任和算法的抽象化

#### 1.3.1 不变模式 Immutable
一个对象的状态在被创建之后就不再变化

#### 1.3.2 策略模式 Strategy -- 对象的行为模式
策略算法将不同的算法封装到不同的具体策略类中，使得算法可以在不影响客户端的情况下发生变化

#### 1.3.3 模版方法模式 Template Method -- 类的行为模式
模版方法模使得抽象类可以实现公共部分的逻辑，提供抽象方法来让子类实现剩余的不通用的逻辑

####  1.3.4 观察者模式 Observer -- 对象的行为模式
观察者模式可以让多个观察者对象同时监听一个主题对象，使得主题对象发生变化的时候，可以得到通知，做出反应。


#### 1.3.5 迭代子模式 Iterator/Cursor --对象的行为模式
迭代子模式使得可以顺序的访问一个聚集中的元素，而不必暴露聚集的内部表象。

#### 1.3.6 责任链模式 Chain of Responsibility -- 对象的行为模式
责任链模式中每个对象持有对下家的引用形成一条链，请求最终在这条上上的某个对象进行处理。
客户端不需要也不知道具体会是哪个对象处理。因此可以在不影响客户端的情况下重新组织或者分配责任。


#### 1.3.7 命令模式 Command -- 对象的行为模式
命名模式将一个请求或者操作封装到一个Command对象中，相当于将客户端的请求或者操作参数化了，将发号命令与执行命令的责任分离了。
这个请求或者操作就可以被执行命令的几个角色干预，进行排队或者记录日志。
结合备忘录模式，可以实现命令的撤销和恢复

#### 1.3.8 备忘录模式 Memento/Snapshot -- 对象的行为模式
备忘录模式将一个对象的状态捕捉住存储起来，从而可以在将来合适的时候把这个对象还原到之前的状态

#### 1.3.9 状态模式 State -- 对象的行为模式
状态模式使得一个对象在状态改变时状态对象也发生了改变，使得其行为也发生了改变。

#### 1.3.10 访问者模式 Visitor -- 对象的行为模式
访问者模式通过双重委派的机制使得数据结构与作用于该数据结构不同类型元素的操作得以脱耦。
当某个操作需要修改的时候，这个数据结构就不需要改变。

#### 1.3.11 解释器模式 Interpret -- 类的行为模式
解释器模式可以根据定义的文法，通过解释器来解释给定的表达式。

#### 1.3. 12 调停者模式 Mediator -- 对象的行为模式
调停者模式包装了一系列对象的相互作用的方式，使得这些对象不必互相明显引用，可以比较松散地耦合在一起。
使得这些相互作用可以彼此独立的变化。
 








## 二、四大原则
### 2.1 "开-闭"原则
### 2.2 "组合/聚合复用原则"
    "组合/聚合复用原则" 是达到"开-闭"原则要求的必要手段。
    因为继承是一种静态关系，而委派是一种动态关系。
    
    
## 三 UML 相关
UML(统一建模语言，Unified Modeling Language)
包括以下图，
* 结构型
    * 包图   Package
    * 类图   Class    
    * 对象图 Object    一个系统中对象的快照
    * 构件图 Component 描述可以部署的软件构件（比如jar包，EJB等）之间的关系
    * 部署图 Deploy    描述一个系统的拓扑图
* 行为型
    * 用例图 Use Case  描述角色与使用案例及他们之间的关系，用来对一个系统的最基本行为建模
    * 活动图 Activity  用例图的具体化，描述不同过程之间的动态接触
    * 状态图 State     一系列对象的内部状态及状态的变化和转移，一个类不能有两个不同的状态图
    * 序列图 Sequence  一种相互作用图，描述不同对象之间信息传递的时序
    * 合作图 Collaboration 一种相互作用图，描述发送信息和接收信息的一系列对象的<b>组织</b>结构
其中用例图，类图和时序图是最有用的。
只要有意义，所有类型的UML图是可以混合在一起使用的。
一个系统的设计，从用例图开始，而且一个设计应当是案例驱动的。

描述设计模式一般使用类图，时序图，状态图就可以了。

### 3.1 类图
* 结构层次
    * 类名
    * 字段
    * 方法：静态方法有下划线
    * 属性
* 修饰符
    * '+' ：public
    * '#' ：protected
    * '-' ：private
* 关系
    * 依赖关系（Dependency）：【虚线】关系的对象出现在局部变量或者方法参量中，或者关系的类的静态方法被调用
        > 依赖总是单向的，代表一个类依赖于另外一个类的定义。
    * 关联关系（Association）：【实线】作为实例变量出现
        > 使一个类知道另一个类的属性和方法。不鼓励双向的关联（双向可以省略两边的箭头）。
        > 更多的是在同一个层次上的两个类
    * 聚合关系（Aggregation）：【实线+空心菱形】作为实例变量出现，且是整体与部分之间的关系
        > 较强的关联关系，涉及的两个类处在不平等的层次上，一个代表整体比如汽车，一个代表部分，比如轮胎，引擎以及其他零部件
        > 如果不确定是否为聚合关系，可以设置为关联关系
    * 组合关系（Composition）：【实线+实心菱形】作为成员变量出现，且维护关系对象的生命周期
        > 最强的关联关系，要求代表整体的对象负责代表部分的对象的生命周期。
        > 合成关系是不能共享的，也就是代表部分的对象只能由一个代表整体的对象所持有。
        > 代表整体的对象可以将代表部分的对象传递给另外一个对象，由后者负此对象的生命周期。
        > 比如人和心脏，四肢等。
    * 一般化关系：【实线+空心三角形】extends
    * 实现关系：【虚线+空心三角形】implements
    
### 3.2 时序图
 * 结构
    * 生命线：垂直的虚线
    * 激活条：小矩形，代表持续的时间
> 当没有返回值(void)的时候，返回的箭头可以不标注
      
### 3.3 状态图
* 结构
    * 起始状态：黑点
    * 过渡连线：由两部分组成(方框内是事件的保护条件，满足条件才会发生过渡），引起过渡的事件[保护条件]/事件发生引起的操作，
            第一部分是发生在该对象的事件(该对象是宾语），第二部分是该对象会产生什么响应操作。
    * 历史状态图标：记住系统离开时的状态
    * 终态图标：代表对象湮灭的状态
> 状态可以嵌套，大的状态叫父状态或者超状态，小的叫子状态。    

### 3.4 UML工具
一些是绘图工具，一些是具有代码生成能力的，甚至有些可以双向工作，代码与URML双向转换，或者时序图与合作图双向转换。
常见的有 Microsoft Visio, StarUML, Diagrams.net, PlantUML等
[PlantUML](https://plantuml.com/zh/)可以在Typora中使用, 并且有idea插件
/**
 * 【类的行为模式】解释器模式
 *          0. 理解
 *              0.1 一句话概括：
 *              0.2 定义一个【语言】，解释器根据其定义好的【文法，即一系列组合规则】，解释这个语言中的句子。
 *              0.3 浏览器，解释器
 *                  文字性语言 ---浏览器 翻译---> 解释器语言（比如抽象语法树AST） ---解释器 解释
 *          1. 用意：如果一类问题一而再地发生，一个有意义的做法是将此类问题模板化，表达为一个简单语言中的语句，
 *          这样，建造一个解释器，就可以解析这些语句，达到解决问题的目的。
 *          2. 结构
 *              2.1 抽象表达式 Expression: 定义解释操作interpret()
 *              2.2 终结符表达式 TerminalExpression：递归过程终止的表达式
 *              2.3 非终结表达式 NonTerminalExpression：需要继续递归的表达式
 *              2.4 环境          Context:  提供变量的真实量值
 *              2.5 客户端         Client: 建造一个AST抽象语法树，并调用解释操作
 *          3. 是否满足开闭
 *          4. 应用场景
 *          5. 实现
 *          6. 与其他模式关系
 *              6.1 与合成模式：被解释的表达式所在的抽象语法树就是建立在合成模式的基础之上。
 *                      终结表达式就是树叶节点，非终结表达式就是复合（树枝）节点。
 *                      解释器模式要求这个树结构描述的是一个语言的文法，也就是要在一个有语言时，才谈得上解释器模式
 *              6.2 不变模式与享元模式
 *                  为了减少重复和相似的表达式对象的数量，可以将一些表达式对象设计为不变模式，从而可以使用享元模式共享这些表达式
 *              6.3 迭代子模式
 *                  在解释器模式遍历抽象语法树AST及其节点的时候，要用到迭代子模式
 *              6.4 访问者模式
 *                  如果使用访问者模式将各个抽象语法树AST的节点的操作转移到一个访问者类中的话，解释器模式可以有更多的灵活性
 *              6.5 状态模式
 *                  解释器模式中的环境对象Context往往可以使用状态模式实现。
 *                  当执行完一个操作之后，context中的状态可能发生了变化，其后续行为可能也会变化。
 *          7. 实例：
 *              7.1 字符串模式匹配，通过一般性的算法(解释器）解释这个模式，进行匹配。
 *              7.2 活动的规则引擎（也是一对规则的and，or等）
 *              7.3 sql语法树解析，比如sqlParser，druid的parser
 *          8. 优缺点
 *
 *
 *
 */
package info.wufc.learning.design_pattern.interpreter;
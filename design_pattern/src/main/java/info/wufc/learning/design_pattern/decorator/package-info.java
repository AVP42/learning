/**
 * 装饰模式decorator: 是包裹模式wrapper的一种（还有一种为适配器模式）
 *       1.用意：以一种对客户端透明的方式拓展对象的功能，是继承的一种替代方案
 *       2.优缺点，功能与使用场景：
 *              2.1  拓展一个类的功能，或者给一个类增加附加责任 （这个是其他模式也可实现的，是一种基本前提）
 *              2.2  可以使得类功能的添加是动态的（最终形成层层包裹图），而且这些功能可以动态的撤销（装饰对象被垃圾回收器回收），不像静态继承关系
 *              2.3  需要增加的功能是需要有一些基本功能排列组合形成的比较复杂的功能，使用继承关系不太现实（会造成非常多的类）
 *                      可以与策略模式结合，实现同时使用多种算法/基本功能的增强
 *          缺点：
 *              1）这种比继承更加灵活激动的特性，意味着装饰模式更加容易出错，主要体现在进行功能的排列组合上会出现不合理或者荒谬的组合，甚至循环引用的错误
 *              2）虽然使用委派的方式，使得类的数量减少了，但是每次装饰都会产生1个新对象，造成对象数量过多
 *       3.实现方式与角色：通过委派的方式实现
 *              2.1 抽象构建角色：需要被装饰添加附加责任的抽象类
 *              2.2 具体构建角色：真正接收附加责任的实现类
 *              2.3 装饰角色（可以是抽象的）：持有具体构建角色的实例，并且定义与抽象构建角色一样的接口
 *              2.4 具体装饰角色：真正实现将附加责任添加给构建角色实例的装饰实现类
 *           >> 简化：
 *                  1） 抽象构建角色可以省去，对于具体构建角色只有一种的情况下
 *                  2） 装饰角色可以省去，对于具体装饰角色只有一种的情况下
 *           >> 退化：半透明化的模式，介于适配器模式与理想装饰模式之间
 *              在装饰角色中定义了公共的方法，使得装饰角色改变了接口，客户端需要调用该公共方法的话，必须使用装饰类变量，使得不那么透明
 *           >> 拓展：
 *              如果有需要，装饰角色又可以作为其他装饰角色的抽象构建角色，作为其他装饰角色需要在装饰角色1的基础上进行增强
 * <br>  4.模式的使用：
 *              注意应当使得抽象构建角色尽可能轻，因为装饰角色是继承于抽象构建角色的，附加功能应当放到装饰角色中
 *
 * <br>  5.与其他模式的关系
 *              5.1 与桥梁模式：都通过委派的方式避免了继承带来的类膨胀问题，区别在于解决思路的不同
 *                      比如对于一个继承体系中有两个基类，两个基类都有很多子类，如何重构使得客户端需要较少的子类（注意，这里说明的是客户端需要的类，并不是系统上所有的类数量减少了）
 *                          1）桥梁模式的方式：
 *                              将两个基类的实现化细节抽取出，构建到一个实现化的等级结构中，并对于变化因素更为静态的基类，继续使用继承关系，改造成抽象化结构
 *                                  虽然不能实现像装饰模式的嵌套，但是可以使连续使用来拓展，比如实现化结构可以作为其他实现化结构中的抽象化结构
 *                          2）装饰模式的方式：
 *                              将子类中比基类多出来的功能封装到一个单独的类中，且持有基类对象，可以达到子类的效果
 *                                  当这个单独的类与持有的对象具有相同的接口时，说明持有的基类对象就可以是其他装饰过的对象，从而实现嵌套，实现功能的排列组合
 *              5.2 与适配模式：两者都有一个别名，叫包装模式，两者的区别在于用意不同
 *                      适配模式用意：改变所考虑对象的接口，而不一定附加功能，将包装对象的api转换成目标接口的api
 *                      装饰模式用意：不改变所考虑对象的接口，来实现功能的附加，保持被包装对象的API
 *              5.3 与策略模式：可以结合使用
 *                      装饰模式：将所考虑的对象包装表面，“内心”还是这个对象，所以这个“内心”的抽象（构建角色）应当尽可能轻
 *                      策略模式：对于所考虑的对象，可以通过另一个对象置换掉，要求抽象策略对象应当尽可能重
 *              5.4 与合成模式：可以结合使用，通常用在拓展合成模式的行为拓展上
 *                      合成模式需要拓展时，如果通过继承关系拓展，那么3种角色都需要派生类，才能保持“多态性”不被破环，而通过装饰模式就可以动态地为合成模式添加新的行为
 *
 *
 *
 */
package info.wufc.learning.design_pattern.decorator;
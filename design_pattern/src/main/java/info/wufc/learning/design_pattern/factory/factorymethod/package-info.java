/**
 * 工厂方法模式：Factory Method 简单工厂模式的缺点都可以使用工厂方法来解决 又称为多态性工厂 Polymorphic Factory
 *      1.角色：
 *          1）抽象工厂角色：定义了工厂方法  是工厂方法模式的核心
 *          2）具体工厂角色：具体实现工厂方法
 *          3）抽象产品角色：产品的抽象
 *          4）具体产品角色：具体产品实现
 *
 *      2. 是否实现“开-闭”原则：完全实现。
 *              引入了抽象工厂的角色，代替简单工厂模式中的上帝工厂，由子类工厂来实现具体的创建逻辑，
 *              常用的结构是平行的等级结构（即由具体工厂来创建相应具体的产品），功能拓展时，只需要引入新的工厂实现类和产品实现类即可，无需修改其他角色，
 *              真正实现“开-闭”原则
 *      3.工厂方法模式与简单工厂模式的对比
 *             1）.核心：工厂方法的核心是抽象工厂类，简单工厂的核心是具体工厂类；
 *                  工厂方法允许具体工厂类从抽象工厂的创建行为继承下来，每一种具体工厂类型都可以是一个简单工厂模式；
 *                  而如果工厂方法模式只有一种具体实现，那么就可以退化成简单工厂模式
 *                  因此可以将工厂方法模式看成是简单工厂模式的综合推广
 *              2）.均对客户端屏蔽了具体产品类型，和具体创建产品的逻辑
 *      4.工厂方法模式实现的拓展：
 *              1)。工厂方法模式中的抽象工厂可以定义多个工厂方法，用来满足创建不同具体产品的功能，
 *                      A.比如在不同继承机构体系的两种产品，但是如果这两种产品构成了产品族的概念，则应当使用抽象工厂设计模式
 *                              因此最好将工厂方法模式应用于单个产品等级结构的场景中，如果没有关联的两种产品等级结构，
 *                              应当使用两个不同的抽象工厂，用不同的工厂方法来创建
 *                      B.比如在同一个继承结构下面，某些特定产品实现了特定的接口，而其他产品没有
 *              2）。产品实例的循环使用：比如享元模式 备忘录模式
 *      5.工厂方法的应用：
 *              1）：在java中的应用，比如Collection中的Iterator()方法，就是一个工厂方法，不同的Collection实现类可以生成不同的Iterator实现；
 *                      同理，List中的listIterator()方法也是如此
 *              2）：在java中的应用，比如URL 与URL Connection
 *              3）：在jdbc jms中的应用，不同的数据库或中间实现实现标准API接口，创建不同的连接对象
 *      6.工厂方法优缺点：
 *              1）优点：解决了简单工厂的缺点：上帝类（维护难，拓展难）
 *              2）缺点：不太适合多个相关联的产品组成的产品族的创建问题上
 *      7.工厂方法模式与其他模式的关系
 *              1）：享元模式中使用
 *              2）：备忘录模式中使用
 *              3）：MVC架构密下的多个Controller->多个modelView中使用
 *              4）：与模版方法联合使用：典型的案例就是 定义一个模版方法，该方法内部有多个抽象工厂方法，子类实现抽象工厂方法，返回不同的产品
 *                      工厂方法模式将创建逻辑交给子类实现
 *                      模版方法将剩余逻辑交给子类实现，
 *                      一旦剩余逻辑就是创建逻辑，那么就是两种方法的混合使用
 *      8.深入理解
 *              1）：工厂方法模式（多态性工厂）的实现用来工厂角色和产品角色的多态性，一旦多态性丢失，那么就发生了退化，不能认为是一个工厂方法模式；
 *                      在特殊的情况下，如果抽象工厂类只有一个具体实现，那么抽象工厂就可以用具体工厂代替，这时工厂的多态性丧失，这时可以用简单工厂模式来替代
 *              2）：工厂方法返回的不一定是新的对象（可能利用登记的方式实现循环使用），但是一定是通过该工厂方法创建的对象；
 *                      反之不一定成立，也就是一个返回新对象的方法不一定就是工厂方法，比如toString()方法 和clone()方法，
 *                      返回了新的对象，但是返回的并不是一个抽象类型，客户端已经事先知道了这个方法返回的真实类型
 *
 *
 */
package info.wufc.learning.design_pattern.factory.factorymethod;
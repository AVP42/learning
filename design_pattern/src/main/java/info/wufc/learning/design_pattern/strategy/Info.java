package info.wufc.learning.design_pattern.strategy;

/**
 * @ClassName: Info
 * @Description: TODO
 * @Info: createdBy alien on 2018/10/7/007 12:21
 */
public class Info {
    /*
    * 策略模式：对象行为模式
    *   1.定义：
    *       定义并封装了一系列方法(具体实现)---具体策略实现
    *       这些方法具有可替换性(共性)--------抽象策略接口，
    *       使得方法的具体实现独立于客户端-----客户端依赖策略接口
    *   2.使用场景：---解决冗余if-else语句，安全封装同一类型的多种操作
    *       > 同一问题的多种处理方式，仅仅是通过if-else或switch来判断具体实行哪种方式
    *       > 同一抽象类下面的多个子类，需要通过if-else或switch-case来判断具体选择哪种子类
    *
    *   3.角色：将之前if-else语句或者继承体系中的   使用策略算法的环境或条件 与 策略算法的行为 隔离开
    *       context--环境角色---即使用策略的角色--持有策略接口的引用
    *       strategy--抽象策略角色
    *       concreteStrategy--具体实现策略
    *
    *   4.优缺点：
    *       4.1 优点：
    *               1) 提供了管理算法族的办法
    *               2） 避免了使用继承或者更为原始的if-else语句将使用算法的环境与算法的行为耦合在一起，不符合开闭原则
    *                       因为使用继承的方法的话，使用算法的环境类就会有子类，每一个子类提供不同的算法，这样，还是将环境与行为混合在一起，使得不能再独立演化
    *       4.2 缺点与解决方法
    *              1) 客户端只能选择不同算法中的一种，如果涉及多个算法嵌套或叠加等多个算法同时执行的情况，就不太适用
    *                   solution: 策略模式+装饰模式
    *              2）何时选择此种算法是在客户端来指定的，所以客户端必须知道所有的算法，而且如果不加以其他模式，就还是会有if-else判断选择算法的语句
    *                   solution: 使用简单工厂的模式 将创建逻辑抽出，再使用注解方式等来拆分if-else语句
    *              3）策略模式会有比较多的策略类，如果每次都是创建出一个对象，那么对象会非常多
    *                   solution：使用享元模式，来使得不同的客户端可以共享这些对象
    *   5.与其他模式的关系
    *       5.1 与建造者模式builder的区别
    *               结构类似，通过委派，可以看成是策略模式的特例
    *               区别在于何时使用，什么情况使用，以及模式的功能
    *                   建造者模式的功能主要是用一步步创建‘零件’的方式来构成返回1个产品对象
    *                   策略模式不仅可以返回1个行为对象，还可以提供任意运行状态的服务（取决于是那个具体策略对象）
    *       5.2 与适配器模式adapter的区别
    *               结构类似，也是通过委派
    *               区别在于用意不同
    *                   适配器用意在于使得客户端可以通过调用一个不同的新接口类完成原来要做的功能
    *                   策略模式用意在于为客户端提供不同算法，管理着一个算法族
    *       5.3 与享元模式flyweight的关系
    *               可以联合使用解决策略对象过多的问题
    *       5.4 与模版模式的关系
    *               模版模式是通过继承的方式来提供不同算法行为
    *               策略模式是通过委派的方式来提供不同的算法行为
    *       5.5 与装饰模式的关系
    *               装饰模式是在不改变接口的前提下，对行为进行增强
    *               策略模式是在保持接口不变的情况下，使得行为可以替换
    *               可以联合使用解决同时使用多个算法/行为的问题
    *   6.与设计原则的关系
    *           体现开闭原则，出现新算法时，实现"可插拔"式的加入
    *           体现里氏代换原则，客户端持有的抽象策略类型可以使用任意一种具体策略类的实例·
    *
    *
    *
    * */
}

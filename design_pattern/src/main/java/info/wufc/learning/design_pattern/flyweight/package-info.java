
/**
 * 【对象的结构模式】享元模式， 轻量模式
 *      0. 理解
 *          0.1 一句话概括：区分不受环境影响的内蕴状态和受环境影响的外蕴状态，将内蕴状态封装到享元角色中实现共享。
 *      1. 用意：以共享的方式高效地支持大量的细粒度对象。
 *              之所以能够做到这点，关键是区分内蕴状态（internal state）和外蕴状态（external state）
 *              内蕴状态是不随着环境改变而改变，是可以共享的，存储在享元内部；
 *              外蕴状态则会改变，不可以共享，由客户端保存，需要的时候再传入享元对象内部。
 *              外蕴状态不可以影响享元独享的内蕴状态，两者是独立的。
 *      2. 结构
 *          2.1 单纯享元模式：所有的享元对象都是可以共享的
 *              1） 抽象享元角色 Flyweight: 定义公共接口，比如外蕴状态可以以参数方式传入的商业方法
 *              2） 具体享元角色 ConcreteFlyweight: 实现公共接口，存储内蕴状态
 *              3） 享元工厂角色 FlyweightFactory：创建和管理享元角色。
 *                      比如客户端调用享元对象的时候，工厂会检查是否已经有一个符合要求的对象，没有就会创建一个合适的享元对象。
 *              4） 客户端角色 Client: 维护对享元对象的引用，存储享元对象的外蕴状态。
 *
 *          2.2 复合享元模式：享元对象构成合成模式.复合享元单元是不能共享的，但是它们可以分解成单纯享元对象，而后者是可以共享的
 *               在该模式下，具体享元角色，也是单纯具体享元角色，是可以共享的；新增了复合享元角色
 *               5） 复合享元角色 unsharableFlyweight: 单纯具体享元角色的组合，没有内蕴状态，不可共享
 *                          所有单纯享元对象的外蕴状态等于复合享元对象的外蕴状态，但是内蕴状态各不相同
 *      3. 是否满足开闭
 *      4. 应用场景：
 *          4.1 当一个系统有大量的对象，耗费了大量的内存，比如一个因素的改变就必须创建一个对象，
 *              我们可以看看是否可以区分出不变的内蕴状态和变化的外蕴状态，从而使用享元模式将内蕴状态共享起来
 *              外蕴状态由客户端或者外界传入，避免需要产生过多的对象。
 *              也就是说当这些对象的状态大部分可以外部化时，我们可以按照内蕴状态进行分组，每一组就只需要一个享元对象。
 *              这些享元对象应该是不可分辨的，全同的。
 *              由于需要一个表来记录并维护所有的享元，所以只有足够多的享元实例时，才值得使用享元模式。
 *           4.2 代码重构的强大武器
 *              设计了一个类，需要使用到大量的对象，而这些实例的状态只有非常少的几种
 *              >>> 可以推论，只需要为不同的状态创建一个实例，让系统共享这些实例就可以了，这就是享元模式。
 *              为了达到共享的目的，客户端不被允许直接创建共享独享，应当使用工厂。
 *              【我们如何将不能共享的状态外部化】：因为状态移出享元对象之后，这些行为仍然需要这些状态
 *                  1）一种是将行为一起移到客户端
 *                     如果有多个客户端的话，不能达到复用的目的，而且会破坏封装。
 *                  2）一种是由客户端提供这些不能共享的状态
 *                      比较合适的方法，需要外蕴状态的时候，再传入来
 *      5. 实现
 *          5.1 使用不变模式实现享元角色。
 *                  享元对象不一定是不变的，但是不变对象创建后不再变化，满足享元模式对享元对象的要求。
 *          5.2 使用备忘录模式实现享元工厂角色
 *                  享元工厂要维护一张表，通过这张表把全同的实例与代表他们的一个对象联系起来。
 *          5.3 使用单例模式实现享元工厂角色
 *      6. 与其他模式关系
 *          6.1 与单例模式
 *              单例模式：一个类只能有一个实例
 *              享元模式：一个类可以有多个实例，每个实例的内蕴状态不一样
 *              享元工厂可以使用单例模式只提供一个工厂实例。
 *          6.2 与工厂方法模式
 *              享元工厂就是一个特殊的工厂方法模式，特殊在于这个工厂维护一个创建过的产品的记录，
 *                  并根据这个记录和产品的内部状态循环使用产品实例。
 *          6.3 与不变模式：享元对象可以使用不变模式实现，但是享元对象不一定是不变对象。
 *                  享元模式对内蕴状态的要求是不可与环境有关。
 *                  因此享元对象允许有可以变化的状态，只要与环境无关就不影响共享
 *                  另一方面所有享元对象的状态是同步变化的，不能只有一个享元对象发生变化，就好像静态变量一样
 *                  比如所有的享元都有一个内蕴状态存储当前时钟。
 *           6.4 与备忘录模式
 *               享元工厂对象维护的表，就是简单的备忘录模式，相当于careTaker和originator
 *           6.5 与状态模式
 *                  状态模式会产生大量的细粒度状态对象，应当认真考虑使用享元模式设计这些状态对象
 *           6.6 策略模式
 *                  策略模式可能需要大量具体策略角色的实例，应当认真考虑使用享元模式设计这些策略对象
 *           6.7 合成模式
 *                  享元可以使用合成模式设计成复合享元
 *      7. 实例：
 *          7.1 在编辑器系统中大量使用，比如文本编辑器。
 *                  一个字母就是一个享元对象，其内蕴状态是这个字母的含义，代表的就是这个字母本身。
 *                  外蕴状态是字母在文本中的位置以及子模风格。
 *           7.2 JAVA中的String类型，就使用了享元模式，由于使用了Immutable模式，每一个String对象都是不变对象。
 *                  如果需要修改字符串中的一个字符，只能创建出新的String对象。为了提高性能，JVM中的String对象是共享的。
 *                  如果一个系统中有两个Stirng对象包含的字符串是相同的，那么JVM实际上只会创建一个Stirng对象提供给两个引用，
 *                  从而实现String对象的共享。使用String.intern()方法可以返回这个字符串在共享池中的唯一实例。
 *            7.3 咖啡摊中，对于咖啡卖单Order, 有内蕴状态：咖啡的口味；外蕴状态：服务的桌子
 *                  如果每一杯咖啡都创建一个对象的话，就需要创建很多细小的对象。
 *                  这样就不如吧咖啡按照口味划分，每种口味的咖啡只需要创建1次，实现共享。不管卖出多少杯咖啡，这些咖啡都是全同的
 *                  不可分辨的。
 *                  共享的是咖啡口味，制造方法。共享意味着咖啡摊主不要为每一份咖啡重新调制口味，而是使用速溶咖啡粉来一次性确定咖啡口味；
 *
 *      8. 优缺点
 *          8.1 优点：大幅度降低对象数量
 *          8.2 缺点：但是代价也是很高，为了实现共享，需要将状态外部化，程序逻辑变复杂；而且读取外部状态使得运行效率降低。
 *
 *
*/
package info.wufc.learning.design_pattern.flyweight;
/**
 * 【对象的行为模式】访问者模式
 *      0. 理解
 *          0.1 一句话概括：封装一些施加于某种数据结构元素之上的操作
 *      1. 用意：将作用域数据结构元素之上的操作与数据结构定义本身进行解耦。这样操作修改时，数据结构就不需要修改。
 *              
 *      2. 结构
 *          2.1 抽象访问者 Visitor: 声明访问操作
 *          2.2 具体访问者 ConcreteVisitor：实现访问操作
 *          2.3 抽象节点角色 Node: 声明接受操作，用于接受访问者对象，作为参量
 *          2.4 具体节点角色：实现接受操作
 *          2.5 结构对象角色：实现遍历节点的操作，可以是高层次的集合，比如LIst,Set
 *      3. 是否满足开闭原则
 *          面向对象最终要的原则就是“开-闭”原则，即对拓展开放，对修改关闭。
 *          达到这个原则的途径就是遵循“对变化的封装”的原则，即将系统中会变化的部分，封装起来
 *
 *      4. 应用场景
 *          访问者模式是一种算法与数据结构分开的设计模式，objectStructure对象含有数据，接受算法的操作。
 *          使用访问者模式，遵循了对算法变化的封装，但是没有遵循对数据结构中元素类型的封装。
 *          4.1 当需要针对一个包含不同类型元素的聚集采取某种操作，而操作的细节根据元素类型的不同而有所不同
 *              比如两个不同类型的元素的操作方法是不同的，不是继承自一个父类的方法。
 *              就会出现对元素类型做类型判断的条件转移语句。而通过代码的方式，我们可以实现双重分派的，
 *              使得这种条件判断语句不再需要
 *              ## 双重分派过程：聚集中的每个元素都可以接受访问者的调用，元素向访问者对象传入自己，
 *                  访问者对象则反过来执行自己的操作。
 *                  这意味着施加于节点（元素）上的操作，不仅仅依赖于该节点的具体类型，还与访问者的具体类型有关
 *                  这就是双重分派。
 *           4.2 可以看出，每一个具体的访问角色，都有对不同类型的节点的访问操作，当需要增加新类型的节点的时候，就需要对visitor等国际结构畸形修改
 *              这时一个系统的大规模修改，是未被开闭原则的；
 *              不过，访问者模式允许在节点中加入新的方法，相应的，仅仅需要在一个新的访问者类中加入该方法，而不需要对所有的visitor都加入
 *              因此，访问者模式提供了倾斜的可拓展性设计：方法集合的可拓展新和类集合的不可拓展性
 *              所以，如果系统的数据结构是频繁变化的，就不适合使用访问者模式。
 *
 *      5. 实现
 *          5.1 示例中的实现使用了visitorB没有使用到，这其实是一个拓展性，在对对象操作进行修改时，结构对象角色时不需要只改的
 *          5.2 示例中的结构对象角色并不是具有多个树枝节点的对象树结构，但是实际上访问者模式通常就是用来处理的对象树结构，
 *                  而且可以用来处理跨越多个等级结构的树结构问题。
 *                  对象数结构的设计可以采用合成模式实现。
 *          5.3 实现时，应当尽可能多的将对象流浪逻辑放在Visitor类中，而不是他的子类，这样ConcreteVisitor对所访问的对象结构依赖较少，维护更加方便
 *          5.4 示例中由结构对象来遍历，我们可以使用一个迭代对象来遍历，甚至交给访问者来遍历（如果遍历逻辑比较负责的话，这时可以省略结构对象）
 *          5.5 还可以通过缺省适配器模式提供visitor的默认实现
 *      6. 与其他模式的关系
 *          6.1 与迭代子模式：
 *                  迭代子模式是针对聚集中同类型元素的设计模式
 *          6.2 与合成模式：访问者模式常常流浪符合合成模式的一些结构对象
 *          6.3 解释器模式：访问者模式可以参与解释器模式的实现
 *
 *      7. 实例
 *          7.1 druid 的visitor
 *          7.2 电脑专卖系统
 *      8. 优缺点
 *          8.1 优点：
 *              1. 对新的操作变化开放，新增操作很容易。这时因为操作不依赖于结构对象
 *              2. 将有关的行为集中到一个访问对象中，而不是分散到一个个节点类中，对节点的操作并不是节点的自身的行为，所以放在节点内部不太合理
 *              3. 可以访问不同等级结构的成员类，而迭代子模式只能访问一个等级结构的成员
 *              4. 访问者对象集中了相关的行为，可以将相关行为操作的状态积累在自己内部，而不是分散到很多节点对象中，有益于系统维护
 *
 *          8.2 缺点
 *              1. 对新的节点类型变化关闭，增加新的节点类型变得很困难
 *              2. 破坏封装，访问者要调用节点对象的操作，可能还要积累状态，这样节点就必须暴露操作和状态，破坏了节点的封装。
 *          有些人喜欢使用，会对访问者模式进行增强，有些人不喜欢使用。
 *
 */
package info.wufc.learning.design_pattern.visitor;
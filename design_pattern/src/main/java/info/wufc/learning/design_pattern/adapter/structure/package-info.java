/**
 * 适配器模式：解决的问题是 将1个类的接口变换为客户端期望的接口，使得两个原本无法一起工作的两个类一起工作
 *          使用1个适配器 adapter 把源adaptee适配到目标去target 又称“变压器模式”
 *  1.角色：
 *      1.1 源角色：adaptee
 *      1.2 目标角色：target
 *      1.3 适配器角色：adapter
 *  2.按照表现形式的不同，分为类适配模式 和 对象适配模式
 *      1.1 类适配模式：定义一个适配器，通过集成源类或者接口，并实现目标接口，在目标接口中的方法实现中，调用源类的方法，并作适配逻辑
 *          优点：可以同时对源类的方法进行置换
 *          缺点：如果我需要对源类的子类也通过这个适配器进行适配，此种实现方式就实现不了了，即解决不了源类继承的问题
 *      1.2 对象适配模式：定义一个适配器，通过持有源类或接口的对象，并实现目标接口，在目标接口的方法实现中，委派源类或接口对象来执行适配逻辑
 *          优点：解决了类适配器的缺点，源类及其子类都可以通过对象适配器类达到适配功能，而且可以很简便的新增适配方法，适配方法也是都适用源类及其子类
 *          缺点：无法直接对源类方法进行置换，只能先拓展一下源类，进行方法置换，再来进行适配
 *  3.适用场景：
 *      1.当前的源类提供的接口不满足系统需求，比如，需要补充源角色没有的接口方法，或者需要置换源角色中的方法
 *      2.建立一个可重复使用的类  用于与一些没有太大关系的类，包括将来可能引入的类一起工作
 *  4.应用：
 *      4.1 在java层面的应用
 *          当一个客户端只知道一个特定的接口(target)，但是又必须与具有不同的类(source/adaptee)打交道时，应当使用适配器模式。
 *      4.2 在架构层面的应用
 *              JDBC的API与ODBC的API不相同，使用了JDBC/ODBC桥梁（只是命名为桥梁，不是桥梁设计模式），来做适配器
 *  5.典故：“指鹿为马” “指方为园”
 *  6.适配器设计模式化的演化
 *      6.1：目标接口可以省去，此时，目标接口与源接口是一个接口 ，比如缺省适配器模式
 *          还有一种情况是，我们没有定义目标接口，但是实际上是实现了对象适配器模式的，来提供新的功能
 *      6.2 适配器类可以是抽象类 比如缺省适配器模式
 *      6.3 带参数的适配器模式
 *   7.缺省适配器模式：
 *          为一个接口或者抽象类提供缺省的默认实现，使得子类不需要全部实现接口定义的方法，就像java8中的default方法
 *   8.与其他模式的关系：
 *          8.1 与桥梁模式：同样也是通过聚合关系，将操作传递给聚合对象来具体实现.
 *                  Abstraction位于客户端与Implementation类之间，目的是隐藏Implementation的实现细节，
 *                  也是一种间接作用的结构，但是在应用和意义上不同，桥梁模式用意是要把接口(机制)和实现分离
 *                  ，以便他们可以独立的变化（机制和实现都有各自的抽象层，两者通过聚合关系来联系起来）
 *                  而适配器模式是将一个已有的对象（source/adaptee），接到一个不相匹配的接口上(target)
 *          8.2 与装饰模式：同样也是通过聚合关系，将操作传递给聚合对象来具体实现.
 *                  Decorator也是位与客户端与component类之间的，目的是增强component的功能。
 *                  也是一种间接作用的结构模式，但是装饰类与component类在接口上完全相同，
 *                  而适配类通过适配源类adaptee的接口方法来提供对目标接口的实现
 *          8.3 与缺省适配器模式：缺省适配器模式是适配器模式的一个特例，目的是使得具体类不必实现所要继承的接口的所有方法
 *
 *  9.是否实现了开闭原则：
 *      拓展功能：源类增加子类
 *      类适配器不支持开闭原则（源类增加子类）
 *      对象适配器器，支持开闭原则（？）
 */
package info.wufc.learning.design_pattern.adapter.structure;
/**
 * 迭代子模式iterator：又称游标模式cursor
 *    1.用意：使得客户端可以顺序的访问一个聚集中的元素而不需要暴露聚集的内部表象（个人理解：可以访问一个Collection聚集对象中的元素 而不需要知道这个对象时list还是set等）
 *          * 为什么需要，是因为在聚集设计最初没有符合“开-闭”原则，没有将不变元素从系统中抽象出来，与可变分割开来，并将可变使用各种实现封装起来
 *              迭代逻辑没变，但是需要将聚集换成另一种聚集，而保持遍历接口不变 >>> 聚集派生子类
 *              聚集没变，但是迭代需要调整，比如之前只是读取元素，现在需要添加元素 >>> 迭代派生子类
 *          该模式将迭代逻辑封装到迭代子对象中，与聚集本身分开；相同的聚集可以提供不同的迭代子，不同的聚集可以提供相同的迭代子；相当于提供了聚集与迭代子独立演化的空间
 *          * 从重构的角度，迭代子模式在客户端与聚集之间增加了一个迭代中介层，缓冲了客户端变化对聚集的影响以及聚集变化对客户端的影响
 *
 *    2.角色：
 *        2.1 抽象迭代子角色
 *        2.2 具体迭代子角色
 *        2.3 聚集角色      定义了创建迭代子角色的接口
 *        2.4 具体聚集角色   实现了创建迭代子角色的接口
 *        2.5 客户端       持有对聚集及其迭代子对象的引用，调用迭代子对象的迭代接口
 *     ** 聚集接口：宽接口  与  窄接口
 *          宽接口：定义了修改聚集元素的方法        >> 这样的聚集叫做“白箱聚集”
 *          窄接口：没有提供修改聚集元素的方法      >> 这样的聚集叫做“黑箱聚集”
 *        > 白箱聚集与外禀迭代子：迭代子可以通过聚集暴露的公共接口从外部控制聚集元素的迭代，这样，迭代子控制的只是游标
 *              >> 这样的迭代子 叫做游标迭代子
 *              >> 由于迭代子是在聚集结构之外的 又叫做外禀迭代子
 *              >> 由于白箱聚集不需要存储游标，所以白箱聚集是可以不变的
 *              >> 缺点：这种给外部提供宽接口，会破坏聚集的封装性，而且修改聚集元素会导致问题
 *              >> 优点：可以被几个不同的方法和对象享用和控制，适用于读取场景
 *        > 黑箱聚集与内禀迭代子：对迭代子对象提供宽接口，对客户端提供窄接口
 *                  >> 实现方式：双重接口
 *                  >> 实现措施： 迭代子类作为聚集类的内部成员类 这种迭代子叫做内禀迭代子
 *                  >> 由于黑箱聚集提供了内禀迭代子对象，该对象会存储游标，所以不可能是不变对象
 *                  >> 优点：不破环封装 可以安全的修改元素
 *                  >> 缺点：不同的迭代需要不同的迭代子对象
 *     ** 静态迭代子与动态迭代子：
 *          静态迭代子由聚集对象创建，并持有聚集对象的快照，创建后，这个快照不会再变化  >> 耗费空间，但是可以不容易出现出错
 *          动态迭代子也是由聚集对象创建，但是保持对聚集对象的引用
 *     3.优点与缺点：
 *          3.1 优点：作为客户端与聚集的中介层，使得聚集与客户端独立变化
 *          3.2 缺点：有些聚集是没有顺序的，迭代起来相似线性顺序，且元素取出都是Object
 *     4.与掐他模式的关系：
 *          4.1 与合成模式：遍历一个合成结构建立的树
 *          4.2 与命令模式：遍历历史命令聚集，实现命令的撤销与恢复
 *          4.3 与备忘录模式：外禀迭代子就是存储了游标状态的备忘录模式对象
 *          4.4 与工厂方法：聚集角色一般提供一个工厂方法
 *
 *
 *
 *
 */
package info.wufc.learning.design_pattern.iterator;
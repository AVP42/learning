# 第二章



为什么需要内存寻址，要从图灵机说起。



图灵机---是一种通用自动的机器模型，是一个计算力无限的理想机器。

* 有一个二端无限延伸的纸带作为存储装置
* 输入、输出、状态转移函数成是机器的三要素
  * 这3个要素的组合可变形成为一切机器的原型，可以解决一切图灵机能够解决的问题

![image-20220102160347952](images/image-20220102160347952.png)





冯诺依曼体系结构

* 与图灵机的关系：图灵机看上去是纸上谈兵，却是冯诺依曼体系结构的理论鼻祖

![image-20220102160407452](images/image-20220102160407452.png)

![image-20220102160529075](images/image-20220102160529075.png)



linux中存放与体系架构相关的代码在arch目录下，最熟悉的就是x86

![image-20220102160552739](images/image-20220102160552739.png)





![image-20220102160653788](images/image-20220102160653788.png)

![image-20220102160816198](images/image-20220102160816198.png)

![image-20220102160846512](images/image-20220102160846512.png)



黄金时代之后的改进都不是质变，所以intel之后的处理器都称为X86	

![image-20220102161018635](images/image-20220102161018635.png)

![image-20220102161327123](images/image-20220102161327123.png)



![image-20220102161416504](images/image-20220102161416504.png)

![image-20220102161523937](images/image-20220102161523937.png)





![image-20220102161534346](images/image-20220102161534346.png)

![image-20220102161540312](images/image-20220102161540312.png)







![image-20220102161750623](images/image-20220102161750623.png)

![image-20220102161824815](images/image-20220102161824815.png)



![image-20220102161937396](images/image-20220102161937396.png)

![image-20220102161949614](images/image-20220102161949614.png)

MMU--内存管理单元  是硬件单元，作用是将虚地址转换为物理地址

![image-20220102162032989](images/image-20220102162032989.png)

![image-20220102162229107](images/image-20220102162229107.png)

![image-20220102162249516](images/image-20220102162249516.png)

![image-20220102162304406](images/image-20220102162304406.png)

段描述符表的表项就是段描述符

![image-20220102162349688](images/image-20220102162349688.png)

![image-20220102162601317](images/image-20220102162601317.png)

![image-20220102162611530](images/image-20220102162611530.png)

![image-20220102162748043](images/image-20220102162748043.png)

0表示高特权级--内核态   3表示第特权级--用户态    保护操作系统

![image-20220102162831139](images/image-20220102162831139.png)

![image-20220102162954290](images/image-20220102162954290.png)





分页机制

![image-20220102163429373](images/image-20220102163429373.png)

x86规定分页机制是可选的，但是操作系统主要采用的是分页机制

![image-20220102163533931](images/image-20220102163533931.png)

32位操作系统，页面一般默认的是4K大小，也可以是2MB或者4MB

64位，最大可以达到256MB

![image-20220102163928509](images/image-20220102163928509.png)

![image-20220102163938411](images/image-20220102163938411.png)

![image-20220102164000370](images/image-20220102164000370.png)

![image-20220102164010398](images/image-20220102164010398.png)

![image-20220102164118650](images/image-20220102164118650.png)

![image-20220102164158999](images/image-20220102164158999.png)

![image-20220102164329666](images/image-20220102164329666.png)

TLB 转换旁路缓冲器  快表  有90%的命中率



linux中是如何分页的：

主要采用分页机制，巧妙绕过了段机制

为了不使用段机制：为了可移植性，很多cpu并不支持端

目前很多处理器都采用64位处理器，linux采用了4级分页模式

![image-20220102164454245](images/image-20220102164454245.png)

在海量内存中如何使用大页内存

![image-20220102165935124](images/image-20220102165935124.png)



在进程中，我们不直接对物理地址进行操作。

cpu在运行指定的地址要讲过MMU转换后才能访问到真正的物理内存。

逻辑地址--分段--> 虚拟地址(线性地址) --分页-> 物理地址

转换分为两部分，分块，分页

分段机制简单来说就是将进程的代码，数据，栈分在不同的虚拟地址段上，从而避免进程之间的相互影响

![image-20220102170609684](images/image-20220102170609684.png)

在linux中，为了可移植性，没有完整使用分段机制，让所有的段都指向相同的段地址范围，即将段号全部置为0.

![image-20220102170831756](images/image-20220102170831756.png)

linux目前采用4级页面模型，可兼容32位和64位。

比如32位，两级页表就足够了，中间的页上级目录和也中间目录的表项都置为1



由于64位处理器的限制，其地址线只有48条，线性地址实际使用的只有48位。

64位linux地址中使用了4级分页机制。在4.x内核版本，已经出现5级分页。

CR3寄存器---cpu控制寄存器，保存当前进程的页全局目录。

内核在创建进程的时候金辉为他分配页全局目录，在进程描述符task_struct结构中有一个指向mm_struct结构的指针mm, mm_struct结构就是用来描述进程的虚拟地址空间的，有一个PGD字段，就是保存了页面全局目录的物理地址的。

进程切换时，操作系统根据PGD字段，得到地址，填充到CR3寄存器当中，完成页表的切换

![image-20220102171113889](images/image-20220102171113889.png)




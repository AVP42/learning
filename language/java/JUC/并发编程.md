#### 其他

内存溢出：
map
threadLocal可能导致溢出，如果这个线程是不会死亡的，是内存泄漏





inharitedThreadLocal仅仅在new Thread()的时候传递，从父线程传递到子线程

而[TransmittableThreadLocal](https://github.com/alibaba/transmittable-thread-local)则可以保证在线程池中传递，而且线程被回收时会将threadLocal变量中的值删除

> 在使用线程池等会池化复用线程的执行组件情况下，提供`ThreadLocal`值的传递功能，解决异步执行时上下文传递的问题
>
> `JDK`的[`InheritableThreadLocal`](https://docs.oracle.com/javase/10/docs/api/java/lang/InheritableThreadLocal.html)类可以完成父线程到子线程的值传递。但对于使用线程池等会池化复用线程的执行组件的情况，线程由线程池创建好，并且线程是池化起来反复使用的；这时父子线程关系的`ThreadLocal`值传递已经没有意义，应用需要的实际上是把 **任务提交给线程池时**的`ThreadLocal`值传递到 **任务执行时**。

任务提交时的线程的本地变量传递到任务执行时选中的那个线程的本地变量。

本库提供的[`TransmittableThreadLocal`](https://github.com/alibaba/transmittable-thread-local/blob/master/src/main/java/com/alibaba/ttl/TransmittableThreadLocal.java)类继承并加强`InheritableThreadLocal`类，解决上述的问题，使用详见 [User Guide](https://github.com/alibaba/transmittable-thread-local#-user-guide)。

使用javasists做增强

> `TransmittableThreadLocal`继承`InheritableThreadLocal`，使用方式也类似。相比`InheritableThreadLocal`，添加了
>
> 1. `copy`方法
>    用于定制 **任务提交给线程池时** 的`ThreadLocal`值传递到 **任务执行时** 的拷贝行为，缺省传递的是引用。
>    注意：如果跨线程传递了对象引用因为不再有线程封闭，与`InheritableThreadLocal.childValue`一样，使用者/业务逻辑要注意传递对象的线程安全。
> 2. `protected`的`beforeExecute`/`afterExecute`方法
>    执行任务(`Runnable`/`Callable`)的前/后的生命周期回调，缺省是空操作。

要保证在线程池中传递，

有3种方式：

[原理](https://juejin.cn/post/6998552093795549191)

* 修饰runnable和callable

  * 使用装饰者模式对两个接口进行包装，

    * 包装的时候获取到任务提交时的本地变量，包括TTL线程变量A和普通线程变量B

    * run方法执行之前，replay重放TTLThreadLocalA，并且对原有的线程池中执行该任务的线程原有的ThreadLocalB进行备份

    * run方法执行之后，restore备份的ThreadLocal，删除TTLThreadLocal

      > 1. TTL为什么不直接继承ThreadLocal？
      >    - 因为有些业务需要用到ITL特性，如果直接继承ThreadLocal，就会丢失ITL的父拷贝到子线程数据的特性(子线程创建时拷贝)
      >
      > 2. 为什么需要在run执行完之后调用restore()？
      >
      >    - restore里面会主动调用remove()回收，避免内存泄露（会删除子线程新增的TTL）
      >
      >    - 不调用restore()的话，就会覆盖之前backup备份部分子线程的数据，这样可能在业务上有隐患
      >
      > 3. TTL存在线程安全问题？
      >    - 存在的，因为默认都是引用类型拷贝，如果子线程修改了数据，主线程是可以感知到的
      >
      > 4. TTL是否存在内存泄露问题？
      >    - TTL维护的holder本身是一个static来的，使用的时候会调用restore(),然后里面显式调用remove()清楚子线程新增TTL，所以正确使用下是没有内存泄露问题

  ![TTL时序图.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c40940117b7b4360a4ec83fc677b341e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

* 修饰线程池  在execute或者submit值之前将runnable和callable装饰城TtlRunnable和TtlCallable

  * 修饰接口Exectutor
  * 修饰接口ExecutorService
  * 修饰接口ScheduledExecutorService

* agent方式  使用javasists来实现下面代码的的改写

  * 增强ThreadPoolExecutor和ScheduledThreadPoolExecutor
  * 增强ForkJoinTask（对应的执行器是ForkJoinPool）
  * 增强TimerTask（执行器是Timer）

  >  Java 8引入的CompletableFuture与（并行执行的）Stream底层是通过ForkJoinPool来执行，所以支持ForkJoinPool后，TTL也就透明支持了CompletableFuture与Stream

  Timer的缺点：单线程，异常会终止，推荐使用scheduledExecutorService







## 线程状态

![image-20220315232625197](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220315232625197.png)





![image-20220317224519806](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220317224519806.png)

![image-20220317224535206](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220317224535206.png)

![image-20220317224544209](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220317224544209.png)